name: Discord Chat Shared

on:
  workflow_call:
    inputs:
      runner_group:
        description: "GitHub runner group for self-hosted runners"
        required: true
        type: string
      worker_url:
        description: "Public Cloudflare worker base URL"
        required: true
        type: string
      chat_session_key:
        description: "Chat session key from Discord gateway"
        required: true
        type: string
      chat_session_token:
        description: "Signed short-lived chat session token"
        required: true
        type: string
      prompt_text:
        description: "Latest user prompt text"
        required: true
        type: string
      mode:
        description: "chat or codex"
        required: false
        type: string
        default: "chat"
      trigger_login:
        description: "Linked GitHub login for the Discord user"
        required: false
        type: string
        default: ""
      discord_user_id:
        description: "Discord user ID that triggered the dispatch"
        required: false
        type: string
        default: ""
      codex_model:
        description: "Model used for codex mode"
        required: false
        type: string
        default: "gpt-5.3-codex"
      extra_instructions:
        description: "Additional prompt instructions appended after the base instructions."
        required: false
        type: string
        default: ""
      extra_common_instructions:
        description: "Additional prompt instructions appended after the common instructions block."
        required: false
        type: string
        default: ""
      chat_model:
        description: "Model used for chat mode"
        required: false
        type: string
        default: "gpt-5.2"

jobs:
  discord_chat:
    concurrency:
      group: >-
        ${{ format(
          'discord-chat:{0}:{1}',
          github.repository,
          inputs.chat_session_key
        ) }}
      cancel-in-progress: true
    runs-on:
      group: ${{ inputs.runner_group }}
    permissions:
      actions: write
      checks: write
      contents: write
      deployments: write
      id-token: write
      issues: write
      discussions: write
      packages: write
      pages: write
      pull-requests: write
      repository-projects: write
      security-events: write
      statuses: write
    steps:
      - name: Validate required inputs
        shell: bash
        env:
          WORKER_URL: ${{ inputs.worker_url }}
          CHAT_SESSION_KEY: ${{ inputs.chat_session_key }}
          CHAT_SESSION_TOKEN: ${{ inputs.chat_session_token }}
          PROMPT_TEXT: ${{ inputs.prompt_text }}
        run: |
          set -euo pipefail

          if [ -z "${WORKER_URL:-}" ]; then
            echo "worker_url input is required"
            exit 1
          fi
          if [ -z "${CHAT_SESSION_KEY:-}" ]; then
            echo "chat_session_key input is required"
            exit 1
          fi
          if [ -z "${CHAT_SESSION_TOKEN:-}" ]; then
            echo "chat_session_token input is required"
            exit 1
          fi
          if [ -z "${PROMPT_TEXT:-}" ]; then
            echo "prompt_text input is required"
            exit 1
          fi

      - name: Checkout target branch (self-hosted)
        shell: bash
        env:
          BRANCH: ${{ github.event.repository.default_branch || github.ref_name }}
          REF_SHA: ${{ github.sha }}
        run: |
          set -euo pipefail

          # Use the same self-hosted checkout flow used by Codex shared workflows.
          # Do not replace this with actions/checkout.
          if [ -z "${ACTIONS_ID_TOKEN_REQUEST_URL:-}" ] || [ -z "${ACTIONS_ID_TOKEN_REQUEST_TOKEN:-}" ]; then
            echo "::error::OIDC env vars missing; ensure job permissions include 'id-token: write'."
            exit 1
          fi
          oidc_url="${ACTIONS_ID_TOKEN_REQUEST_URL}"

          oidc_body="${RUNNER_TEMP}/oidc-token.json"
          oidc_headers="${RUNNER_TEMP}/oidc-token.headers"
          rm -f "$oidc_body" "$oidc_headers"

          set +e
          oidc_http_code="$(
            curl -sS \
              -H "Authorization: Bearer ${ACTIONS_ID_TOKEN_REQUEST_TOKEN}" \
              -H "Accept: application/json" \
              -D "$oidc_headers" \
              -o "$oidc_body" \
              -w "%{http_code}" \
              "$oidc_url"
          )"
          curl_rc="$?"
          set -e
          if [ "$curl_rc" -ne 0 ]; then
            echo "::error::Failed to request OIDC token (curl exit ${curl_rc})."
            exit 1
          fi
          if [ "$oidc_http_code" != "200" ]; then
            http_line="$(head -n 1 "$oidc_headers" | tr -d '\r')"
            location="$(
              grep -i '^location:' "$oidc_headers" | head -n 1 | sed -E 's/^[Ll]ocation:[[:space:]]*//' | tr -d '\r' || true
            )"
            body_bytes="$(wc -c < "$oidc_body" | tr -d ' ')"
            echo "::error::OIDC token request failed (${http_line:-HTTP ${oidc_http_code}})."
            if [ -n "$location" ]; then
              echo "::error::OIDC token request redirected to: ${location}"
            fi
            echo "::error::OIDC token response body bytes: ${body_bytes}"
            exit 1
          fi

          workflow_claims="$(python3 - "$oidc_body" <<'PY'
          import base64
          import json
          import sys

          oidc_body = sys.argv[1]
          raw = open(oidc_body, "r", encoding="utf-8").read()
          if not raw.strip():
            raise SystemExit("OIDC token response is empty")

          data = json.loads(raw)
          if not isinstance(data, dict):
            raise SystemExit("OIDC token response is not a JSON object")

          token = (
            (data.get("value") or "")
            or (data.get("token") or "")
            or (data.get("id_token") or "")
          ).strip()
          if not token:
            keys = sorted(list(data.keys()))
            raise SystemExit(f"OIDC token response missing token field (keys: {keys})")

          parts = token.split(".")
          if len(parts) < 2:
            raise SystemExit("OIDC token is not a JWT")

          payload_b64 = parts[1]
          payload_b64 += "=" * (-len(payload_b64) % 4)

          payload = base64.urlsafe_b64decode(payload_b64.encode("utf-8")).decode("utf-8")
          claims = json.loads(payload)

          called_workflow_ref = (
            (claims.get("job_workflow_ref") or "")
            or (claims.get("workflow_ref") or "")
          ).strip()
          called_workflow_sha = (
            (claims.get("job_workflow_sha") or "")
            or (claims.get("workflow_sha") or "")
          ).strip()
          if not called_workflow_ref:
            keys = sorted(list(claims.keys()))
            raise SystemExit(f"OIDC token missing workflow_ref claim (keys: {keys})")
          print(called_workflow_ref)
          print(called_workflow_sha)
          PY
          )"

          called_workflow_ref="$(printf '%s' "$workflow_claims" | sed -n '1p')"
          called_workflow_sha="$(printf '%s' "$workflow_claims" | sed -n '2p')"
          if [ -z "$called_workflow_ref" ]; then
            echo "::error::Unable to resolve called workflow ref from OIDC token; cannot locate shared checkout script."
            exit 1
          fi

          workflow_repo_path="${called_workflow_ref%@*}"
          workflow_repo="$(printf '%s' "$workflow_repo_path" | cut -d/ -f1-2)"
          ref="$called_workflow_sha"
          if [ -z "$ref" ]; then
            case "$called_workflow_ref" in
              *@*) ref="${called_workflow_ref#*@}" ;;
              *)
                echo "::error::Called workflow ref is missing an @<ref> suffix: ${called_workflow_ref}"
                exit 1
                ;;
            esac
            case "$ref" in
              refs/heads/*) ref="${ref#refs/heads/}" ;;
              refs/tags/*) ref="${ref#refs/tags/}" ;;
            esac
          fi
          echo "Resolved reusable workflow source: ${workflow_repo}@${ref}"

          checkout_script="${RUNNER_TEMP}/self-hosted-checkout.sh"
          script_url="https://raw.githubusercontent.com/${workflow_repo}/${ref}/.github/scripts/self-hosted-checkout.sh"
          echo "Fetching shared checkout script: ${script_url}"
          curl -fsSL "$script_url" -o "$checkout_script"
          chmod +x "$checkout_script"

          bash "$checkout_script"

      - name: Locate Codex executable
        id: exes
        shell: bash
        run: |
          set -euo pipefail

          if [ -f ~/.local/bin/codex ]; then
            CODEX_PATH=~/.local/bin/codex
          elif [ -f /opt/homebrew/bin/codex ]; then
            CODEX_PATH=/opt/homebrew/bin/codex
          elif command -v codex >/dev/null 2>&1; then
            CODEX_PATH=$(command -v codex)
          else
            echo "ERROR: codex not found"
            exit 1
          fi

          echo "codex_path=$CODEX_PATH" >> "$GITHUB_OUTPUT"
          echo "Found codex executable: $CODEX_PATH"

      - name: Fetch chat session context
        id: session
        shell: bash
        env:
          WORKER_URL: ${{ inputs.worker_url }}
          CHAT_SESSION_KEY: ${{ inputs.chat_session_key }}
          CHAT_SESSION_TOKEN: ${{ inputs.chat_session_token }}
        run: |
          set -euo pipefail

          SESSION_FILE="${RUNNER_TEMP}/discord-chat-session.json"
          BASE_URL="${WORKER_URL%/}"

          curl -fsS -G \
            --data-urlencode "session_key=${CHAT_SESSION_KEY}" \
            --data-urlencode "token=${CHAT_SESSION_TOKEN}" \
            "${BASE_URL}/chat/session/get" \
            -o "${SESSION_FILE}"

          echo "session_file=${SESSION_FILE}" >> "$GITHUB_OUTPUT"

      - name: Build Codex chat prompt
        id: prompt
        shell: bash
        env:
          SESSION_FILE: ${{ steps.session.outputs.session_file }}
          MODE_INPUT: ${{ inputs.mode }}
          PROMPT_TEXT: ${{ inputs.prompt_text }}
          TRIGGER_LOGIN: ${{ inputs.trigger_login }}
          DISCORD_USER_ID: ${{ inputs.discord_user_id }}
          CODEX_MODEL_INPUT: ${{ inputs.codex_model }}
          EXTRA_INSTRUCTIONS: ${{ inputs.extra_instructions }}
          EXTRA_COMMON_INSTRUCTIONS: ${{ inputs.extra_common_instructions }}
        run: |
          set -euo pipefail

          python3 - <<'PY'
          import json
          import os
          import textwrap
          from pathlib import Path

          session_file = os.environ["SESSION_FILE"]
          prompt_text = (os.environ.get("PROMPT_TEXT", "") or "").strip()
          trigger_login = (os.environ.get("TRIGGER_LOGIN", "") or "").strip()
          discord_user_id = (os.environ.get("DISCORD_USER_ID", "") or "").strip()
          codex_model = (os.environ.get("CODEX_MODEL_INPUT", "") or "").strip()
          extra_instructions = (os.environ.get("EXTRA_INSTRUCTIONS", "") or "").strip()
          extra_common_instructions = (os.environ.get("EXTRA_COMMON_INSTRUCTIONS", "") or "").strip()

          with open(session_file, "r", encoding="utf-8") as handle:
            payload = json.load(handle)

          if not isinstance(payload, dict) or not payload.get("ok"):
            raise SystemExit("Worker session lookup failed.")
          if not payload.get("found"):
            raise SystemExit("Chat session was not found in worker storage.")

          session = payload.get("session") or {}
          if not isinstance(session, dict):
            raise SystemExit("Session payload is invalid.")

          selected_model = codex_model
          if not selected_model:
            raise SystemExit("No model selected for chat run.")

          repository = str(session.get("repository") or os.environ.get("GITHUB_REPOSITORY", "")).strip()
          session_key = str(session.get("session_key") or "").strip()
          ref_name = str(os.environ.get("GITHUB_REF_NAME") or "").strip()
          workspace = os.environ.get("GITHUB_WORKSPACE", "")
          discord_user_name = str(session.get("user_display_name") or "").strip()
          messages = session.get("messages") if isinstance(session.get("messages"), list) else []

          MAX_CONTEXT_MESSAGES = 30
          MAX_NEWEST_MESSAGES = 2
          OLDER_MESSAGE_CHAR_LIMIT = 8000

          def truncate(text: str, max_chars: int) -> str:
            normalized = str(text or "")
            if len(normalized) <= max_chars:
              return normalized
            return normalized[:max_chars] + "...(truncated)"

          normalized_messages = []
          for message in messages[-80:]:
            if not isinstance(message, dict):
              continue
            role = str(message.get("role") or "").strip().lower()
            content = str(message.get("content") or "").strip()
            if role not in ("user", "assistant") or not content:
              continue
            normalized_messages.append({"role": role, "content": content})
          deduped_messages = []
          for message in normalized_messages:
            if (
              deduped_messages
              and deduped_messages[-1]["role"] == message["role"]
              and deduped_messages[-1]["content"] == message["content"]
            ):
              continue
            deduped_messages.append(message)
          normalized_messages = deduped_messages[-MAX_CONTEXT_MESSAGES:]

          if not prompt_text:
            for message in reversed(normalized_messages):
              if message["role"] == "user":
                prompt_text = message["content"]
                break
          if not prompt_text:
            raise SystemExit("Latest prompt text is empty.")

          def append_instruction_block(base: str, extra: str) -> str:
            normalized_extra = (extra or "").strip()
            if not normalized_extra:
              return base
            normalized_extra = textwrap.dedent(normalized_extra).strip()
            if not normalized_extra:
              return base
            return base + "\n" + normalized_extra

          repo_extra_instructions_path = (
            Path(workspace) / ".github" / "codex-extra-instructions.md"
          )
          if repo_extra_instructions_path.exists():
            extra_instructions = append_instruction_block(
              extra_instructions,
              repo_extra_instructions_path.read_text(encoding="utf-8"),
            )
          repo_extra_common_instructions_path = (
            Path(workspace) / ".github" / "codex-extra-common-instructions.md"
          )
          if repo_extra_common_instructions_path.exists():
            extra_common_instructions = append_instruction_block(
              extra_common_instructions,
              repo_extra_common_instructions_path.read_text(encoding="utf-8"),
            )

          transcript_lines = []
          newest_start_index = max(0, len(normalized_messages) - MAX_NEWEST_MESSAGES)
          human_speaker = discord_user_name or "User"
          for index, message in enumerate(normalized_messages):
            speaker = human_speaker if message["role"] == "user" else "Codex"
            content = (
              message["content"]
              if index >= newest_start_index
              else truncate(message["content"], OLDER_MESSAGE_CHAR_LIMIT)
            )
            transcript_lines.append(f"{speaker}\n{content}")
          comments_text = "\n\n---\n\n".join(transcript_lines) if transcript_lines else "(no comments)"

          codex_instructions = textwrap.dedent(
            """\
            * I use voice dictation; expect typos and confirm if ambiguous.
            * Don't guess & assume. If you're not sure what I mean, ask me.
            * If implementation intent is unclear, ask a clarifying question instead of editing.
            * Prefer deterministic, pure, functional code, with TDD.
            * Don't write flakey code that can break easily.
            * Refactor & reuse as needed to avoid duplicate code.
            * Commit only files relevant to the task. Do not include unrelated changes.
            * You can update issue's description using gh. Do so as needed.
            * Pass real newlines for PR bodies (via --body-file or a heredoc/printf).
            """
          ).strip()

          common_instructions = textwrap.dedent(
            """\
            * To download attachments from Discord messages, use: `curl -L "<attachment-url>" -o "<filename>"`. Download one file at a time, use the exact format i provided, don't try to create a script to combine downloads or use tmp directories. Stick to a single file with that exact format.
            """
          ).strip()

          codex_instructions = append_instruction_block(
            codex_instructions,
            extra_instructions,
          )
          common_instructions = append_instruction_block(
            common_instructions,
            extra_common_instructions,
          )

          issue_instructions = (
            "If you made code changes, create a PR (make sure tests pass and link the issue in the PR description). "
            "If you made code changes but decide not to create a PR, push your WIP branch and mention its name in your response."
          )

          discord_user_display = f"<@{discord_user_id}>" if discord_user_id else "<unknown>"
          linked_github_display = f"@{trigger_login}" if trigger_login else "<none>"
          trigger_line = (
            f"Triggered by Discord user: {discord_user_name} ({discord_user_display})"
            if discord_user_name
            else f"Triggered by Discord user: {discord_user_display}"
          )
          prompt = (
            codex_instructions
            + "\n"
            + common_instructions
            + "\n\n"
            + issue_instructions
            + "\n\n"
            + textwrap.dedent(
              f"""\
              * Don't post comments on Github. To respond to the user, our workflow will automatically post your response to Discord.
              * Use the GitHub CLI (gh) to interact with GitHub (issues, PRs, comments).
              * You're @codex. You were triggered by Discord user: {discord_user_name or '<unknown>'} ({discord_user_display}).
              * The linked GitHub user for this Discord session is: {linked_github_display}.
              """
            ).strip()
            + "\n\n"
            + f"Repository: {repository}\n"
            + f"Session key: {session_key}\n"
            + f"Current branch: {ref_name or '<unknown>'}\n"
            + f"{trigger_line}\n"
            + f"Discord user name: {discord_user_name or '<unknown>'}\n"
            + f"Linked GitHub user: {linked_github_display}\n"
            + "Active PR: none\n"
            + f"Workspace: {workspace}\n\n"
            + "Latest messages (oldest to newest):\n"
            + f"{comments_text}\n"
          )

          prompt_path = Path(os.environ["GITHUB_WORKSPACE"]) / ".github" / "discord_chat_prompt.txt"
          prompt_path.parent.mkdir(parents=True, exist_ok=True)
          prompt_path.write_text(prompt, encoding="utf-8")

          with open(os.environ["GITHUB_OUTPUT"], "a", encoding="utf-8") as output:
            output.write(f"prompt_file={prompt_path}\n")
            output.write(f"model={selected_model}\n")
            output.write("mode=codex\n")
            output.write(f"repository={repository}\n")
          PY

      - name: Run Codex for Discord chat
        id: codex
        continue-on-error: true
        shell: bash
        env:
          CODEX_PATH: ${{ steps.exes.outputs.codex_path }}
          PROMPT_FILE: ${{ steps.prompt.outputs.prompt_file }}
          CODEX_MODEL: ${{ steps.prompt.outputs.model }}
          GITHUB_TOKEN: ${{ github.token }}
          GH_TOKEN: ${{ github.token }}
          CODEX_GH_TOKEN: ${{ github.token }}
        run: |
          set -euo pipefail

          if [ -z "${CODEX_PATH:-}" ] || [ ! -x "${CODEX_PATH}" ]; then
            echo "ERROR: codex executable is missing"
            exit 1
          fi
          if [ -z "${PROMPT_FILE:-}" ] || [ ! -f "${PROMPT_FILE}" ]; then
            echo "ERROR: prompt file is missing"
            exit 1
          fi
          if [ -z "${CODEX_MODEL:-}" ]; then
            echo "ERROR: selected model is empty"
            exit 1
          fi

          TASK="$(cat "${PROMPT_FILE}")"
          OUTPUT_FILE="${GITHUB_WORKSPACE}/.github/discord_chat_output.txt"

          echo "Running model: ${CODEX_MODEL}"
          "${CODEX_PATH}" exec --model "${CODEX_MODEL}" --yolo "${TASK}" > "${OUTPUT_FILE}"
          echo "output_file=${OUTPUT_FILE}" >> "$GITHUB_OUTPUT"

      - name: Build bridge response payload
        id: response_payload
        if: always()
        shell: bash
        env:
          CHAT_SESSION_KEY: ${{ inputs.chat_session_key }}
          CHAT_SESSION_TOKEN: ${{ inputs.chat_session_token }}
          CODEX_OUTPUT_FILE: ${{ steps.codex.outputs.output_file }}
          CODEX_OUTCOME: ${{ steps.codex.outcome }}
          RUN_URL: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
          PAYLOAD_FILE: ${{ runner.temp }}/discord-chat-response.json
        run: |
          set -euo pipefail

          python3 - <<'PY'
          import json
          import os
          from pathlib import Path

          session_key = (os.environ.get("CHAT_SESSION_KEY", "") or "").strip()
          session_token = (os.environ.get("CHAT_SESSION_TOKEN", "") or "").strip()
          output_file = (os.environ.get("CODEX_OUTPUT_FILE", "") or "").strip()
          codex_outcome = (os.environ.get("CODEX_OUTCOME", "") or "").strip().lower()
          run_url = (os.environ.get("RUN_URL", "") or "").strip()
          payload_file = (os.environ.get("PAYLOAD_FILE", "") or "").strip()

          response_text = ""
          if output_file:
            candidate = Path(output_file)
            if candidate.exists():
              response_text = candidate.read_text(encoding="utf-8", errors="replace").strip()

          if not response_text:
            if codex_outcome == "success":
              response_text = "Completed successfully, but no response text was produced."
            else:
              response_text = "Run failed before producing a response. Open the workflow run for details."

          outcome = "success" if codex_outcome == "success" else "failure"
          payload = {
            "session_key": session_key,
            "token": session_token,
            "response_text": response_text,
            "outcome": outcome,
            "run_url": run_url,
          }

          with open(payload_file, "w", encoding="utf-8") as handle:
            json.dump(payload, handle, ensure_ascii=False)

          with open(os.environ["GITHUB_OUTPUT"], "a", encoding="utf-8") as output:
            output.write(f"payload_file={payload_file}\n")
          PY

      - name: Deliver response to Discord bridge
        if: always()
        shell: bash
        env:
          WORKER_URL: ${{ inputs.worker_url }}
          PAYLOAD_FILE: ${{ steps.response_payload.outputs.payload_file }}
        run: |
          set -euo pipefail

          if [ -z "${PAYLOAD_FILE:-}" ] || [ ! -f "${PAYLOAD_FILE}" ]; then
            echo "ERROR: response payload file missing"
            exit 1
          fi

          curl -fsS \
            -X POST \
            -H "Content-Type: application/json" \
            --data-binary @"${PAYLOAD_FILE}" \
            "${WORKER_URL%/}/chat/session/respond" >/dev/null
