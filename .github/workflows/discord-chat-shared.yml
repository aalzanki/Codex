name: Discord Chat Shared

on:
  workflow_call:
    inputs:
      runner_group:
        description: "GitHub runner group for self-hosted runners"
        required: true
        type: string
      worker_url:
        description: "Public Cloudflare worker base URL"
        required: true
        type: string
      chat_session_key:
        description: "Chat session key from Discord gateway"
        required: true
        type: string
      chat_session_token:
        description: "Signed short-lived chat session token"
        required: true
        type: string
      prompt_text:
        description: "Latest user prompt text"
        required: true
        type: string
      mode:
        description: "Reserved for future use; Discord chat runs in codex mode."
        required: false
        type: string
        default: "codex"
      trigger_login:
        description: "Linked GitHub login for the Discord user"
        required: false
        type: string
        default: ""
      discord_user_id:
        description: "Discord user ID that triggered the dispatch"
        required: false
        type: string
        default: ""
      codex_model:
        description: "Model used for codex mode"
        required: false
        type: string
        default: "gpt-5.3-codex"
      extra_instructions:
        description: "Additional prompt instructions appended after the base instructions."
        required: false
        type: string
        default: ""
      extra_common_instructions:
        description: "Additional prompt instructions appended after the common instructions block."
        required: false
        type: string
        default: ""
      extra_env:
        description: "Optional newline-separated KEY=VALUE pairs injected into the Codex runtime environment (non-secret values only)."
        required: false
        type: string
        default: ""
      extra_secret_env_1_name:
        description: "Optional environment variable name for secrets.EXTRA_SECRET_ENV_1."
        required: false
        type: string
        default: ""
      extra_secret_env_2_name:
        description: "Optional environment variable name for secrets.EXTRA_SECRET_ENV_2."
        required: false
        type: string
        default: ""
      extra_secret_env_3_name:
        description: "Optional environment variable name for secrets.EXTRA_SECRET_ENV_3."
        required: false
        type: string
        default: ""
      extra_secret_env_4_name:
        description: "Optional environment variable name for secrets.EXTRA_SECRET_ENV_4."
        required: false
        type: string
        default: ""
      extra_secret_env_5_name:
        description: "Optional environment variable name for secrets.EXTRA_SECRET_ENV_5."
        required: false
        type: string
        default: ""
    secrets:
      CODEX_GH_TOKEN:
        required: true
      EXTRA_SECRET_ENV_1:
        required: false
      EXTRA_SECRET_ENV_2:
        required: false
      EXTRA_SECRET_ENV_3:
        required: false
      EXTRA_SECRET_ENV_4:
        required: false
      EXTRA_SECRET_ENV_5:
        required: false

jobs:
  discord_chat:
    concurrency:
      group: >-
        ${{ format(
          'discord-chat:{0}:{1}',
          github.repository,
          inputs.chat_session_key
        ) }}
      cancel-in-progress: true
    runs-on:
      group: ${{ inputs.runner_group }}
    permissions:
      actions: write
      checks: write
      contents: write
      deployments: write
      id-token: write
      issues: write
      discussions: write
      packages: write
      pages: write
      pull-requests: write
      repository-projects: write
      security-events: write
      statuses: write
    steps:
      - name: Validate required inputs
        shell: bash
        env:
          WORKER_URL: ${{ inputs.worker_url }}
          CHAT_SESSION_KEY: ${{ inputs.chat_session_key }}
          CHAT_SESSION_TOKEN: ${{ inputs.chat_session_token }}
          PROMPT_TEXT: ${{ inputs.prompt_text }}
        run: |
          set -euo pipefail

          if [ -z "${WORKER_URL:-}" ]; then
            echo "worker_url input is required"
            exit 1
          fi
          if [ -z "${CHAT_SESSION_KEY:-}" ]; then
            echo "chat_session_key input is required"
            exit 1
          fi
          if [ -z "${CHAT_SESSION_TOKEN:-}" ]; then
            echo "chat_session_token input is required"
            exit 1
          fi
          if [ -z "${PROMPT_TEXT:-}" ]; then
            echo "prompt_text input is required"
            exit 1
          fi

      - name: Fetch chat session context
        id: session
        shell: bash
        env:
          WORKER_URL: ${{ inputs.worker_url }}
          CHAT_SESSION_KEY: ${{ inputs.chat_session_key }}
          CHAT_SESSION_TOKEN: ${{ inputs.chat_session_token }}
        run: |
          set -euo pipefail

          SESSION_FILE="${RUNNER_TEMP}/discord-chat-session.json"
          BASE_URL="${WORKER_URL%/}"

          curl -fsS -G \
            --data-urlencode "session_key=${CHAT_SESSION_KEY}" \
            --data-urlencode "token=${CHAT_SESSION_TOKEN}" \
            "${BASE_URL}/chat/session/live" \
            -o "${SESSION_FILE}"

          echo "session_file=${SESSION_FILE}" >> "$GITHUB_OUTPUT"

      - name: Determine target branch from Discord context
        id: branch
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');

            const ISSUE_LINKED_PRS_QUERY = `
              query ResolveIssueLinkedPullRequests(
                $owner: String!
                $repo: String!
                $issueNumber: Int!
                $linkedPrQueryLimit: Int!
              ) {
                repository(owner: $owner, name: $repo) {
                  issue(number: $issueNumber) {
                    closedByPullRequestsReferences(last: $linkedPrQueryLimit) {
                      nodes {
                        number
                        url
                        state
                        isCrossRepository
                        headRefName
                        createdAt
                      }
                    }
                    timelineItems(
                      last: $linkedPrQueryLimit
                      itemTypes: [CROSS_REFERENCED_EVENT, CONNECTED_EVENT]
                    ) {
                      nodes {
                        __typename
                        ... on CrossReferencedEvent {
                          source {
                            ... on PullRequest {
                              number
                              url
                              state
                              isCrossRepository
                              headRefName
                              createdAt
                            }
                          }
                        }
                        ... on ConnectedEvent {
                          subject {
                            ... on PullRequest {
                              number
                              url
                              state
                              isCrossRepository
                              headRefName
                              createdAt
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            `;

            const ISSUE_LINKED_PRS_QUERY_LIMIT = 50;

            const toIssueLinkedPullRequest = (node) => {
              if (!node || typeof node !== 'object') {
                return null;
              }
              if (typeof node.number !== 'number') {
                return null;
              }
              return {
                number: node.number,
                url: typeof node.url === 'string' ? node.url : '',
                state: typeof node.state === 'string' ? node.state : '',
                isCrossRepository: node.isCrossRepository === true,
                headRefName:
                  typeof node.headRefName === 'string'
                    ? node.headRefName.trim()
                    : '',
                createdAt:
                  typeof node.createdAt === 'string' ? node.createdAt : '',
              };
            };

            const toTimestamp = (createdAt) => {
              const timestamp = Date.parse(createdAt);
              return Number.isFinite(timestamp) ? timestamp : -1;
            };

            const compareIssueLinkedPullRequests = (left, right) => {
              const createdAtDiff =
                toTimestamp(left.createdAt) - toTimestamp(right.createdAt);
              if (createdAtDiff !== 0) {
                return createdAtDiff;
              }
              return left.number - right.number;
            };

            const selectActiveIssueLinkedPullRequest = (issueNode) => {
              if (!issueNode) {
                return null;
              }

              const byNumber = new Map();
              const appendCandidate = (candidate) => {
                if (!candidate) {
                  return;
                }
                if (!byNumber.has(candidate.number)) {
                  byNumber.set(candidate.number, candidate);
                }
              };

              const closedByNodes =
                issueNode.closedByPullRequestsReferences?.nodes || [];
              for (const node of closedByNodes) {
                appendCandidate(toIssueLinkedPullRequest(node));
              }

              const timelineNodes = issueNode.timelineItems?.nodes || [];
              for (const timelineNode of timelineNodes) {
                if (!timelineNode) {
                  continue;
                }
                if (timelineNode.__typename === 'CrossReferencedEvent') {
                  appendCandidate(toIssueLinkedPullRequest(timelineNode.source));
                  continue;
                }
                if (timelineNode.__typename === 'ConnectedEvent') {
                  appendCandidate(toIssueLinkedPullRequest(timelineNode.subject));
                }
              }

              let activeCandidate = null;
              for (const candidate of byNumber.values()) {
                const isSafeCandidate =
                  candidate.state === 'OPEN' &&
                  candidate.isCrossRepository === false &&
                  candidate.headRefName.length > 0;
                if (!isSafeCandidate) {
                  continue;
                }

                if (
                  !activeCandidate ||
                  compareIssueLinkedPullRequests(candidate, activeCandidate) > 0
                ) {
                  activeCandidate = candidate;
                }
              }

              return activeCandidate;
            };

            const resolveIssueLinkedPullRequest = async ({
              owner,
              repo,
              issueNumber,
            }) => {
              const response = await github.graphql(ISSUE_LINKED_PRS_QUERY, {
                owner,
                repo,
                issueNumber,
                linkedPrQueryLimit: ISSUE_LINKED_PRS_QUERY_LIMIT,
              });
              const issueNode = response?.repository?.issue || null;
              return selectActiveIssueLinkedPullRequest(issueNode);
            };

            const resolveDefaultBranch = async () => {
              const repo = await github.rest.repos.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
              });
              return String(repo.data?.default_branch || '').trim();
            };

            const doesBranchExist = async (branchName) => {
              const normalizedBranch = String(branchName || '').trim();
              if (!normalizedBranch) {
                return false;
              }
              try {
                await github.rest.repos.getBranch({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  branch: normalizedBranch,
                });
                return true;
              } catch (error) {
                const status = Number(error?.status || error?.response?.status || 0);
                if (status === 404) {
                  return false;
                }
                throw error;
              }
            };

            const sessionFile = String(process.env.SESSION_FILE || '').trim();
            if (!sessionFile) {
              core.setFailed('SESSION_FILE is required.');
              return;
            }

            let payload = null;
            try {
              payload = JSON.parse(fs.readFileSync(sessionFile, 'utf8'));
            } catch (error) {
              core.setFailed(`Unable to parse session JSON: ${error.message}`);
              return;
            }

            if (!payload || typeof payload !== 'object' || !payload.ok || !payload.found) {
              core.setFailed('Worker session lookup failed before branch resolution.');
              return;
            }

            const session = payload.session || {};
            const issueType = String(session.issue_type || '').trim().toLowerCase();
            const issueNumber = Number.parseInt(String(session.issue_number || ''), 10);
            const threadUrl = String(session.thread_url || '').trim();

            let branch = context.payload.repository?.default_branch || null;
            let activePrNumber = '';
            let activePrUrl = '';

            if (issueType === 'pull_request' && Number.isFinite(issueNumber) && issueNumber > 0) {
              const pr = await github.rest.pulls.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: issueNumber,
              });
              branch = pr.data?.head?.ref || branch;
              activePrNumber = String(pr.data?.number || '');
              activePrUrl = String(pr.data?.html_url || '');
            } else if (issueType === 'issue' && Number.isFinite(issueNumber) && issueNumber > 0) {
              try {
                const linkedPullRequest = await resolveIssueLinkedPullRequest({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issueNumber,
                });
                if (linkedPullRequest) {
                  branch = linkedPullRequest.headRefName;
                  activePrNumber = String(linkedPullRequest.number);
                  activePrUrl = linkedPullRequest.url || '';
                }
              } catch (error) {
                core.warning(
                  `Linked PR branch resolution failed for issue #${issueNumber}: ${error.message}`
                );
              }
            }

            if (branch) {
              try {
                const branchExists = await doesBranchExist(branch);
                if (!branchExists) {
                  core.warning(
                    `Resolved branch '${branch}' does not exist on origin; falling back to default branch.`
                  );
                  branch = '';
                  activePrNumber = '';
                  activePrUrl = '';
                }
              } catch (error) {
                core.warning(
                  `Unable to verify branch '${branch}'; proceeding with fallback branch resolution: ${error.message}`
                );
                branch = '';
              }
            }

            if (!branch) {
              branch = await resolveDefaultBranch();
            }

            core.setOutput('branch', branch || '');
            core.setOutput('active_pr_number', activePrNumber);
            core.setOutput('active_pr_url', activePrUrl || threadUrl);
            core.setOutput('issue_type', issueType);
            core.setOutput('issue_number', Number.isFinite(issueNumber) && issueNumber > 0 ? String(issueNumber) : '');
            core.setOutput('thread_url', threadUrl);

            const activePrDisplay = activePrNumber
              ? `#${activePrNumber}${activePrUrl ? ` (${activePrUrl})` : ''}`
              : 'none';
            core.info(`Discord context branch: ${branch} (active PR: ${activePrDisplay})`);
        env:
          SESSION_FILE: ${{ steps.session.outputs.session_file }}

      - name: Checkout target branch (self-hosted)
        shell: bash
        env:
          BRANCH: ${{ steps.branch.outputs.branch }}
          REF_SHA: ${{ github.sha }}
        run: |
          set -euo pipefail

          # Use the same self-hosted checkout flow used by Codex shared workflows.
          # Do not replace this with actions/checkout.
          if [ -z "${ACTIONS_ID_TOKEN_REQUEST_URL:-}" ] || [ -z "${ACTIONS_ID_TOKEN_REQUEST_TOKEN:-}" ]; then
            echo "::error::OIDC env vars missing; ensure job permissions include 'id-token: write'."
            exit 1
          fi
          oidc_url="${ACTIONS_ID_TOKEN_REQUEST_URL}"

          oidc_body="${RUNNER_TEMP}/oidc-token.json"
          oidc_headers="${RUNNER_TEMP}/oidc-token.headers"
          rm -f "$oidc_body" "$oidc_headers"

          set +e
          oidc_http_code="$(
            curl -sS \
              -H "Authorization: Bearer ${ACTIONS_ID_TOKEN_REQUEST_TOKEN}" \
              -H "Accept: application/json" \
              -D "$oidc_headers" \
              -o "$oidc_body" \
              -w "%{http_code}" \
              "$oidc_url"
          )"
          curl_rc="$?"
          set -e
          if [ "$curl_rc" -ne 0 ]; then
            echo "::error::Failed to request OIDC token (curl exit ${curl_rc})."
            exit 1
          fi
          if [ "$oidc_http_code" != "200" ]; then
            http_line="$(head -n 1 "$oidc_headers" | tr -d '\r')"
            location="$(
              grep -i '^location:' "$oidc_headers" | head -n 1 | sed -E 's/^[Ll]ocation:[[:space:]]*//' | tr -d '\r' || true
            )"
            body_bytes="$(wc -c < "$oidc_body" | tr -d ' ')"
            echo "::error::OIDC token request failed (${http_line:-HTTP ${oidc_http_code}})."
            if [ -n "$location" ]; then
              echo "::error::OIDC token request redirected to: ${location}"
            fi
            echo "::error::OIDC token response body bytes: ${body_bytes}"
            exit 1
          fi

          workflow_claims="$(python3 - "$oidc_body" <<'PY'
          import base64
          import json
          import sys

          oidc_body = sys.argv[1]
          raw = open(oidc_body, "r", encoding="utf-8").read()
          if not raw.strip():
            raise SystemExit("OIDC token response is empty")

          data = json.loads(raw)
          if not isinstance(data, dict):
            raise SystemExit("OIDC token response is not a JSON object")

          token = (
            (data.get("value") or "")
            or (data.get("token") or "")
            or (data.get("id_token") or "")
          ).strip()
          if not token:
            keys = sorted(list(data.keys()))
            raise SystemExit(f"OIDC token response missing token field (keys: {keys})")

          parts = token.split(".")
          if len(parts) < 2:
            raise SystemExit("OIDC token is not a JWT")

          payload_b64 = parts[1]
          payload_b64 += "=" * (-len(payload_b64) % 4)

          payload = base64.urlsafe_b64decode(payload_b64.encode("utf-8")).decode("utf-8")
          claims = json.loads(payload)

          called_workflow_ref = (
            (claims.get("job_workflow_ref") or "")
            or (claims.get("workflow_ref") or "")
          ).strip()
          called_workflow_sha = (
            (claims.get("job_workflow_sha") or "")
            or (claims.get("workflow_sha") or "")
          ).strip()
          if not called_workflow_ref:
            keys = sorted(list(claims.keys()))
            raise SystemExit(f"OIDC token missing workflow_ref claim (keys: {keys})")
          print(called_workflow_ref)
          print(called_workflow_sha)
          PY
          )"

          called_workflow_ref="$(printf '%s' "$workflow_claims" | sed -n '1p')"
          called_workflow_sha="$(printf '%s' "$workflow_claims" | sed -n '2p')"
          if [ -z "$called_workflow_ref" ]; then
            echo "::error::Unable to resolve called workflow ref from OIDC token; cannot locate shared checkout script."
            exit 1
          fi

          workflow_repo_path="${called_workflow_ref%@*}"
          workflow_repo="$(printf '%s' "$workflow_repo_path" | cut -d/ -f1-2)"
          ref="$called_workflow_sha"
          if [ -z "$ref" ]; then
            case "$called_workflow_ref" in
              *@*) ref="${called_workflow_ref#*@}" ;;
              *)
                echo "::error::Called workflow ref is missing an @<ref> suffix: ${called_workflow_ref}"
                exit 1
                ;;
            esac
            case "$ref" in
              refs/heads/*) ref="${ref#refs/heads/}" ;;
              refs/tags/*) ref="${ref#refs/tags/}" ;;
            esac
          fi
          echo "Resolved reusable workflow source: ${workflow_repo}@${ref}"

          checkout_script="${RUNNER_TEMP}/self-hosted-checkout.sh"
          script_url="https://raw.githubusercontent.com/${workflow_repo}/${ref}/.github/scripts/self-hosted-checkout.sh"
          echo "Fetching shared checkout script: ${script_url}"
          curl -fsSL "$script_url" -o "$checkout_script"
          chmod +x "$checkout_script"

          bash "$checkout_script"

      - name: Locate Codex executable
        id: exes
        shell: bash
        run: |
          set -euo pipefail

          if [ -f ~/.local/bin/codex ]; then
            CODEX_PATH=~/.local/bin/codex
          elif [ -f /opt/homebrew/bin/codex ]; then
            CODEX_PATH=/opt/homebrew/bin/codex
          elif command -v codex >/dev/null 2>&1; then
            CODEX_PATH=$(command -v codex)
          else
            echo "ERROR: codex not found"
            exit 1
          fi

          echo "codex_path=$CODEX_PATH" >> "$GITHUB_OUTPUT"
          echo "Found codex executable: $CODEX_PATH"

      - name: Configure git identity
        shell: bash
        env:
          CODEX_GIT_USER_NAME: ${{ vars.CODEX_GIT_USER_NAME }}
          CODEX_GIT_USER_EMAIL: ${{ vars.CODEX_GIT_USER_EMAIL }}
        run: |
          set -euo pipefail

          cd "${GITHUB_WORKSPACE}"
          git config user.name "${CODEX_GIT_USER_NAME:-${GITHUB_ACTOR}}"
          git config user.email "${CODEX_GIT_USER_EMAIL:-${GITHUB_ACTOR}@users.noreply.github.com}"

      - name: Build Codex chat prompt
        id: prompt
        shell: bash
        env:
          SESSION_FILE: ${{ steps.session.outputs.session_file }}
          PROMPT_TEXT: ${{ inputs.prompt_text }}
          TRIGGER_LOGIN: ${{ inputs.trigger_login }}
          DISCORD_USER_ID: ${{ inputs.discord_user_id }}
          TARGET_BRANCH: ${{ steps.branch.outputs.branch }}
          ACTIVE_PR_NUMBER: ${{ steps.branch.outputs.active_pr_number }}
          ACTIVE_PR_URL: ${{ steps.branch.outputs.active_pr_url }}
          CODEX_MODEL_INPUT: ${{ inputs.codex_model }}
          EXTRA_INSTRUCTIONS: ${{ inputs.extra_instructions }}
          EXTRA_COMMON_INSTRUCTIONS: ${{ inputs.extra_common_instructions }}
        run: |
          set -euo pipefail

          python3 - <<'PY'
          import json
          import os
          import textwrap
          from pathlib import Path

          session_file = os.environ["SESSION_FILE"]
          prompt_text = (os.environ.get("PROMPT_TEXT", "") or "").strip()
          discord_user_id = (os.environ.get("DISCORD_USER_ID", "") or "").strip()
          target_branch = (os.environ.get("TARGET_BRANCH", "") or "").strip()
          active_pr_number = (os.environ.get("ACTIVE_PR_NUMBER", "") or "").strip()
          active_pr_url = (os.environ.get("ACTIVE_PR_URL", "") or "").strip()
          codex_model = (os.environ.get("CODEX_MODEL_INPUT", "") or "").strip()
          extra_instructions = (os.environ.get("EXTRA_INSTRUCTIONS", "") or "").strip()
          extra_common_instructions = (os.environ.get("EXTRA_COMMON_INSTRUCTIONS", "") or "").strip()

          with open(session_file, "r", encoding="utf-8") as handle:
            payload = json.load(handle)

          if not isinstance(payload, dict) or not payload.get("ok"):
            raise SystemExit("Worker session lookup failed.")
          if not payload.get("found"):
            raise SystemExit("Chat session was not found in worker storage.")

          session = payload.get("session") or {}
          if not isinstance(session, dict):
            raise SystemExit("Session payload is invalid.")

          selected_model = codex_model
          if not selected_model:
            raise SystemExit("No model selected for chat run.")

          repository = str(session.get("repository") or os.environ.get("GITHUB_REPOSITORY", "")).strip()
          session_key = str(session.get("session_key") or "").strip()
          ref_name = target_branch or str(os.environ.get("GITHUB_REF_NAME") or "").strip()
          workspace = os.environ.get("GITHUB_WORKSPACE", "")
          thread_issue_type = str(session.get("issue_type") or "").strip().lower()
          thread_issue_number_raw = str(session.get("issue_number") or "").strip()
          thread_url = str(session.get("thread_url") or "").strip()
          try:
            thread_issue_number = int(thread_issue_number_raw) if thread_issue_number_raw else 0
          except Exception:
            thread_issue_number = 0
          raw_session_messages = session.get("messages")
          messages = raw_session_messages if isinstance(raw_session_messages, list) else []

          MAX_CONTEXT_MESSAGES = 30
          MAX_NEWEST_MESSAGES = 2
          OLDER_MESSAGE_CHAR_LIMIT = 8000

          def truncate(text: str, max_chars: int) -> str:
            normalized = str(text or "")
            if len(normalized) <= max_chars:
              return normalized
            return normalized[:max_chars] + "...(truncated)"

          normalized_messages = []
          for message in messages[-80:]:
            if not isinstance(message, dict):
              continue
            role = str(message.get("role") or "").strip().lower()
            content = str(message.get("content") or "").strip()
            if role not in ("user", "assistant") or not content:
              continue
            speaker_name = str(message.get("speaker_name") or "").strip()
            speaker_id = str(message.get("speaker_id") or "").strip()
            discord_message_id = str(message.get("discord_message_id") or "").strip()
            normalized_messages.append(
              {
                "role": role,
                "content": content,
                "speaker_name": speaker_name,
                "speaker_id": speaker_id,
                "discord_message_id": discord_message_id,
              }
            )

          # Keep only true duplicates by Discord message id. Do not collapse
          # repeated user content ("continue", etc.) because each message matters.
          deduped_messages = []
          seen_message_ids = set()
          for message in normalized_messages:
            message_id = str(message.get("discord_message_id") or "").strip()
            if message_id and message_id in seen_message_ids:
              continue
            if message_id:
              seen_message_ids.add(message_id)
            deduped_messages.append(message)
          normalized_messages = deduped_messages[-MAX_CONTEXT_MESSAGES:]

          if not prompt_text:
            for message in reversed(normalized_messages):
              if message["role"] == "user":
                prompt_text = message["content"]
                break
          if not prompt_text:
            raise SystemExit("Latest prompt text is empty.")

          # Guarantee the exact triggering prompt is present in context,
          # even if live message fetch is momentarily stale.
          has_exact_trigger_prompt = False
          for message in reversed(normalized_messages):
            if message["role"] != "user":
              continue
            same_user = True
            if discord_user_id:
              same_user = str(message.get("speaker_id") or "").strip() == discord_user_id
            if same_user and message["content"] == prompt_text:
              has_exact_trigger_prompt = True
              break
          if not has_exact_trigger_prompt:
            trigger_speaker_name = ""
            for message in reversed(normalized_messages):
              if message["role"] != "user":
                continue
              if discord_user_id and str(message.get("speaker_id") or "").strip() != discord_user_id:
                continue
              trigger_speaker_name = str(message.get("speaker_name") or "").strip()
              if trigger_speaker_name:
                break
            normalized_messages.append(
              {
                "role": "user",
                "content": prompt_text,
                "speaker_name": trigger_speaker_name,
                "speaker_id": discord_user_id,
                "discord_message_id": "",
              }
            )
            normalized_messages = normalized_messages[-MAX_CONTEXT_MESSAGES:]

          def append_instruction_block(base: str, extra: str) -> str:
            normalized_extra = (extra or "").strip()
            if not normalized_extra:
              return base
            normalized_extra = textwrap.dedent(normalized_extra).strip()
            if not normalized_extra:
              return base
            return base + "\n" + normalized_extra

          repo_extra_instructions_path = (
            Path(workspace) / ".github" / "codex-extra-instructions.md"
          )
          if repo_extra_instructions_path.exists():
            extra_instructions = append_instruction_block(
              extra_instructions,
              repo_extra_instructions_path.read_text(encoding="utf-8"),
            )
          repo_extra_common_instructions_path = (
            Path(workspace) / ".github" / "codex-extra-common-instructions.md"
          )
          if repo_extra_common_instructions_path.exists():
            extra_common_instructions = append_instruction_block(
              extra_common_instructions,
              repo_extra_common_instructions_path.read_text(encoding="utf-8"),
            )

          transcript_lines = []
          newest_start_index = max(0, len(normalized_messages) - MAX_NEWEST_MESSAGES)
          for index, message in enumerate(normalized_messages):
            speaker = str(message.get("speaker_name") or "").strip()
            if not speaker:
              speaker = "User" if message["role"] == "user" else "Codex"
            content = (
              message["content"]
              if index >= newest_start_index
              else truncate(message["content"], OLDER_MESSAGE_CHAR_LIMIT)
            )
            transcript_lines.append(f"{speaker}\n{content}")
          comments_text = "\n\n---\n\n".join(transcript_lines) if transcript_lines else "(no comments)"

          codex_instructions = textwrap.dedent(
            """\
            * I use voice dictation; expect typos and confirm if ambiguous.
            * Don't guess & assume. If you're not sure what I mean, ask me.
            * If implementation intent is unclear, ask a clarifying question instead of editing.
            * Prefer deterministic, pure, functional code, with TDD.
            * Don't write flakey code that can break easily.
            * Refactor & reuse as needed to avoid duplicate code.
            * Commit only files relevant to the task. Do not include unrelated changes.
            * You can update issue's description using gh. Do so as needed.
            * Pass real newlines for PR bodies (via --body-file or a heredoc/printf).
            """
          ).strip()

          common_instructions = textwrap.dedent(
            """\
            * To download attachments from Discord messages, use: `curl -L "<attachment-url>" -o "<filename>"`. Download one file at a time, use the exact format i provided, don't try to create a script to combine downloads or use tmp directories. Stick to a single file with that exact format.
            * For voice-note/audio transcription, run this exact command (English + large model): `whisper "<audio-file>" --model large-v3 --language en --task transcribe --output_format txt --output_dir . --verbose False`. Do not try tiny/base/small/medium/turbo unless I explicitly ask for a different model.
            """
          ).strip()

          codex_instructions = append_instruction_block(
            codex_instructions,
            extra_instructions,
          )
          common_instructions = append_instruction_block(
            common_instructions,
            extra_common_instructions,
          )

          issue_instructions = (
            "If you made code changes, create a PR (make sure tests pass and link the issue in the PR description). "
            "If you made code changes but decide not to create a PR, push your WIP branch and mention its name in your response."
          )

          discord_user_display = f"<@{discord_user_id}>" if discord_user_id else "<unknown>"
          trigger_user_name = ""
          if discord_user_id:
            for message in reversed(normalized_messages):
              if (
                message.get("role") == "user"
                and str(message.get("speaker_id") or "").strip() == discord_user_id
              ):
                trigger_user_name = str(message.get("speaker_name") or "").strip()
                break
          if not trigger_user_name:
            for message in reversed(normalized_messages):
              if message.get("role") == "user":
                trigger_user_name = str(message.get("speaker_name") or "").strip()
                if trigger_user_name:
                  break
          thread_context_line = "Thread context: none"
          if thread_issue_number > 0 and thread_issue_type in ("issue", "pull_request"):
            issue_label = "PR" if thread_issue_type == "pull_request" else "Issue"
            thread_context_line = f"Thread context: {issue_label} #{thread_issue_number}"
            if thread_url:
              thread_context_line += f" ({thread_url})"
          active_pr_line = "Active PR: none"
          if active_pr_number:
            active_pr_line = f"Active PR: #{active_pr_number}"
            if active_pr_url:
              active_pr_line += f" ({active_pr_url})"
          trigger_line = (
            f"Triggered by Discord user: {trigger_user_name} ({discord_user_display})"
            if trigger_user_name
            else f"Triggered by Discord user: {discord_user_display}"
          )
          prompt = (
            codex_instructions
            + "\n"
            + common_instructions
            + "\n\n"
            + issue_instructions
            + "\n\n"
            + textwrap.dedent(
              f"""\
              * Don't post comments on Github. To respond to the user, our workflow will automatically post your response to Discord.
              * Use the GitHub CLI (gh) to interact with GitHub (issues, PRs, comments).
              * You're @codex. You were triggered by Discord user: {trigger_user_name or '<unknown>'} ({discord_user_display}).
              * Discord channel permissions are the source of access control for this session.
              """
            ).strip()
            + "\n\n"
            + f"Repository: {repository}\n"
            + f"Session key: {session_key}\n"
            + f"Current branch: {ref_name or '<unknown>'}\n"
            + f"{trigger_line}\n"
            + f"{thread_context_line}\n"
            + f"{active_pr_line}\n"
            + f"Workspace: {workspace}\n\n"
            + "Latest messages (oldest to newest):\n"
            + f"{comments_text}\n"
          )

          prompt_path = Path(os.environ["GITHUB_WORKSPACE"]) / ".github" / "discord_chat_prompt.txt"
          prompt_path.parent.mkdir(parents=True, exist_ok=True)
          prompt_path.write_text(prompt, encoding="utf-8")

          with open(os.environ["GITHUB_OUTPUT"], "a", encoding="utf-8") as output:
            output.write(f"prompt_file={prompt_path}\n")
            output.write(f"model={selected_model}\n")
            output.write("mode=codex\n")
            output.write(f"repository={repository}\n")
          PY

      - name: Run Codex for Discord chat
        id: codex
        continue-on-error: true
        shell: bash
        env:
          CODEX_PATH: ${{ steps.exes.outputs.codex_path }}
          PROMPT_FILE: ${{ steps.prompt.outputs.prompt_file }}
          CODEX_MODEL: ${{ steps.prompt.outputs.model }}
          GITHUB_TOKEN: ${{ secrets.CODEX_GH_TOKEN }}
          GH_TOKEN: ${{ secrets.CODEX_GH_TOKEN }}
          CODEX_GH_TOKEN: ${{ secrets.CODEX_GH_TOKEN }}
          CODEX_EXTRA_ENV: ${{ inputs.extra_env }}
          CODEX_EXTRA_SECRET_ENV_1_NAME: ${{ inputs.extra_secret_env_1_name }}
          CODEX_EXTRA_SECRET_ENV_2_NAME: ${{ inputs.extra_secret_env_2_name }}
          CODEX_EXTRA_SECRET_ENV_3_NAME: ${{ inputs.extra_secret_env_3_name }}
          CODEX_EXTRA_SECRET_ENV_4_NAME: ${{ inputs.extra_secret_env_4_name }}
          CODEX_EXTRA_SECRET_ENV_5_NAME: ${{ inputs.extra_secret_env_5_name }}
          CODEX_EXTRA_SECRET_ENV_1_VALUE: ${{ secrets.EXTRA_SECRET_ENV_1 }}
          CODEX_EXTRA_SECRET_ENV_2_VALUE: ${{ secrets.EXTRA_SECRET_ENV_2 }}
          CODEX_EXTRA_SECRET_ENV_3_VALUE: ${{ secrets.EXTRA_SECRET_ENV_3 }}
          CODEX_EXTRA_SECRET_ENV_4_VALUE: ${{ secrets.EXTRA_SECRET_ENV_4 }}
          CODEX_EXTRA_SECRET_ENV_5_VALUE: ${{ secrets.EXTRA_SECRET_ENV_5 }}
        run: |
          set -euo pipefail

          if [ -z "${CODEX_PATH:-}" ] || [ ! -x "${CODEX_PATH}" ]; then
            echo "ERROR: codex executable is missing"
            exit 1
          fi
          if [ -z "${PROMPT_FILE:-}" ] || [ ! -f "${PROMPT_FILE}" ]; then
            echo "ERROR: prompt file is missing"
            exit 1
          fi
          if [ -z "${CODEX_MODEL:-}" ]; then
            echo "ERROR: selected model is empty"
            exit 1
          fi

          is_valid_env_key() {
            local key="$1"
            [[ "$key" =~ ^[A-Za-z_][A-Za-z0-9_]*$ ]]
          }

          export_env_kv() {
            local key="$1"
            local value="$2"

            if ! is_valid_env_key "$key"; then
              echo "ERROR: invalid env var name: ${key}"
              exit 1
            fi

            export "${key}=${value}"
          }

          apply_extra_env_multiline() {
            local payload="$1"
            local label="$2"

            if [ -z "$payload" ]; then
              return 0
            fi

            local line_no=0
            while IFS= read -r line || [ -n "$line" ]; do
              line_no=$((line_no + 1))
              line="${line%$'\\r'}"
              if [ -z "$line" ]; then
                continue
              fi
              case "$line" in
                \#*) continue ;;
              esac
              if [[ "$line" != *"="* ]]; then
                echo "ERROR: ${label} expects KEY=VALUE lines (invalid line ${line_no})"
                exit 1
              fi

              local key="${line%%=*}"
              local value="${line#*=}"

              if [ -z "$key" ]; then
                echo "ERROR: ${label} contains an empty key (line ${line_no})"
                exit 1
              fi

              export_env_kv "$key" "$value"
            done <<< "$payload"
          }

          apply_secret_slot() {
            local slot="$1"
            local key="$2"
            local value="$3"

            if [ -z "$key" ] && [ -z "$value" ]; then
              return 0
            fi
            if [ -z "$key" ]; then
              echo "ERROR: extra secret env slot ${slot} has a value but no name (inputs.extra_secret_env_${slot}_name)"
              exit 1
            fi
            if [ -z "$value" ]; then
              echo "ERROR: extra secret env slot ${slot} name is set but secrets.EXTRA_SECRET_ENV_${slot} is empty/not provided"
              exit 1
            fi

            export_env_kv "$key" "$value"
          }

          # Optional injection of additional environment variables for custom tasks/tools.
          # - inputs.extra_env is for non-secret values.
          # - secrets.EXTRA_SECRET_ENV_N are for secret values, exported to the env var name provided by inputs.extra_secret_env_N_name.
          apply_extra_env_multiline "${CODEX_EXTRA_ENV:-}" "inputs.extra_env"
          apply_secret_slot "1" "${CODEX_EXTRA_SECRET_ENV_1_NAME:-}" "${CODEX_EXTRA_SECRET_ENV_1_VALUE:-}"
          apply_secret_slot "2" "${CODEX_EXTRA_SECRET_ENV_2_NAME:-}" "${CODEX_EXTRA_SECRET_ENV_2_VALUE:-}"
          apply_secret_slot "3" "${CODEX_EXTRA_SECRET_ENV_3_NAME:-}" "${CODEX_EXTRA_SECRET_ENV_3_VALUE:-}"
          apply_secret_slot "4" "${CODEX_EXTRA_SECRET_ENV_4_NAME:-}" "${CODEX_EXTRA_SECRET_ENV_4_VALUE:-}"
          apply_secret_slot "5" "${CODEX_EXTRA_SECRET_ENV_5_NAME:-}" "${CODEX_EXTRA_SECRET_ENV_5_VALUE:-}"

          TASK="$(cat "${PROMPT_FILE}")"
          OUTPUT_FILE="${GITHUB_WORKSPACE}/.github/discord_chat_output.txt"

          echo "Running model: ${CODEX_MODEL}"
          "${CODEX_PATH}" exec --model "${CODEX_MODEL}" --yolo "${TASK}" > "${OUTPUT_FILE}"
          echo "output_file=${OUTPUT_FILE}" >> "$GITHUB_OUTPUT"

      - name: Build bridge response payload
        id: response_payload
        if: ${{ always() && !cancelled() }}
        shell: bash
        env:
          CHAT_SESSION_KEY: ${{ inputs.chat_session_key }}
          CHAT_SESSION_TOKEN: ${{ inputs.chat_session_token }}
          CODEX_OUTPUT_FILE: ${{ steps.codex.outputs.output_file }}
          CODEX_OUTCOME: ${{ steps.codex.outcome }}
          RUN_URL: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
          PAYLOAD_FILE: ${{ runner.temp }}/discord-chat-response.json
        run: |
          set -euo pipefail

          python3 - <<'PY'
          import json
          import os
          from pathlib import Path

          session_key = (os.environ.get("CHAT_SESSION_KEY", "") or "").strip()
          session_token = (os.environ.get("CHAT_SESSION_TOKEN", "") or "").strip()
          output_file = (os.environ.get("CODEX_OUTPUT_FILE", "") or "").strip()
          codex_outcome = (os.environ.get("CODEX_OUTCOME", "") or "").strip().lower()
          run_url = (os.environ.get("RUN_URL", "") or "").strip()
          payload_file = (os.environ.get("PAYLOAD_FILE", "") or "").strip()

          response_text = ""
          if output_file:
            candidate = Path(output_file)
            if candidate.exists():
              response_text = candidate.read_text(encoding="utf-8", errors="replace").strip()

          if not response_text:
            if codex_outcome == "success":
              response_text = "Completed successfully, but no response text was produced."
            else:
              response_text = "Run failed before producing a response. Open the workflow run for details."

          outcome = "success" if codex_outcome == "success" else "failure"
          payload = {
            "session_key": session_key,
            "token": session_token,
            "response_text": response_text,
            "outcome": outcome,
            "run_url": run_url,
          }

          with open(payload_file, "w", encoding="utf-8") as handle:
            json.dump(payload, handle, ensure_ascii=False)

          with open(os.environ["GITHUB_OUTPUT"], "a", encoding="utf-8") as output:
            output.write(f"payload_file={payload_file}\n")
          PY

      - name: Deliver response to Discord bridge
        if: ${{ always() && !cancelled() }}
        shell: bash
        env:
          WORKER_URL: ${{ inputs.worker_url }}
          PAYLOAD_FILE: ${{ steps.response_payload.outputs.payload_file }}
        run: |
          set -euo pipefail

          if [ -z "${PAYLOAD_FILE:-}" ] || [ ! -f "${PAYLOAD_FILE}" ]; then
            echo "ERROR: response payload file missing"
            exit 1
          fi

          curl -fsS \
            -X POST \
            -H "Content-Type: application/json" \
            --data-binary @"${PAYLOAD_FILE}" \
            "${WORKER_URL%/}/chat/session/respond" >/dev/null

      - name: Clear eyes reaction for cancelled run
        if: ${{ cancelled() }}
        continue-on-error: true
        shell: bash
        env:
          WORKER_URL: ${{ inputs.worker_url }}
          CHAT_SESSION_KEY: ${{ inputs.chat_session_key }}
          CHAT_SESSION_TOKEN: ${{ inputs.chat_session_token }}
        run: |
          set -euo pipefail

          PAYLOAD_FILE="${RUNNER_TEMP}/discord-chat-cancel.json"
          python3 - <<'PY' > "${PAYLOAD_FILE}"
          import json
          import os

          payload = {
            "session_key": (os.environ.get("CHAT_SESSION_KEY", "") or "").strip(),
            "token": (os.environ.get("CHAT_SESSION_TOKEN", "") or "").strip(),
          }
          print(json.dumps(payload, ensure_ascii=False))
          PY

          if ! curl -fsS \
            -X POST \
            -H "Content-Type: application/json" \
            --data-binary @"${PAYLOAD_FILE}" \
            "${WORKER_URL%/}/chat/session/cancel" >/dev/null; then
            echo "::warning::Failed to clear Discord eyes reaction for cancelled run."
          fi
